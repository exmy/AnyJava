##### 一、自动内存管理

###### 运行时数据区域

![运行时数据区域](https://github.com/exmy/CSNotes/raw/master/pics/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

​	方法区和堆由所有线程共享

​	虚拟机栈、本地方法栈以及程序计数器每个线程私有

* 程序计数器

  * 一块较小的内存空间，当前线程所执行的字节码的行号指示器（字节码指令的地址）
  * 如果执行的式Native方法，计数器为空

* 虚拟机栈

  * 线程私有，生命周期与线程相同
  * 描述Java方法执行的内存模型：一个方法执行时会创建栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息
  * 一个方法从调用到完成，对应一个栈帧在虚拟机栈中从入栈到出栈
  * 常说的堆内存、栈内存，栈内存就是指虚拟机栈，更确切地说是虚拟机栈中局部变量表的部分
  * 局部变量表存放基本数据类型和对象引用类型，所需内存在编译器就完成分配，方法运行期间不会改变局部变量表的大小
  * 如果线程请求的栈深度大于虚拟机允许的深度，抛出StackOverFlowError异常。虚拟机栈一般可以动态扩展，如果扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。

* 本地方法栈

  * 为虚拟机用到的Native方法服务
  * Sun HotSpot虚拟机把本地方法栈和虚拟机栈合二为一

* java堆

  * 所有线程共享的一块区域，在虚拟机启动时创建，存放对象实例以及数组，因为是所有线程共享，导致创建对象开销比较大，当堆上空间不足时，会触发GC，如果GC后空间仍然不足，抛出OutOfMemory
  * Java堆是垃圾收集器管理的主要区域，也成为“GC堆”
  * 细分为：新生代和老年代。
    * 新生代：存放那些很快就会被回收或者不是特别大的对象
    * 老年代：存放那些经历了好几次回收仍然还存活或者特别大的对象
  * 再进一步细分：Eden空间，From Survivor空间、To Survivor空间
  * 为提升内存分配效率，Eden空间又开辟一小块线程私有的区域，TLAB(Thread Local Allocation Buffer)，其大小由JVM根据运行情况计算而得
    * `-XX:TLABWasteTargetPercent`设置TLAB可占用的Eden的百分比，默认为1%
    * 在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时尽量在TLAB上分配，如果对象过大或TLAB空间用完，才在堆上分配
    * `-XX:+PrintTLAB`查看TLAB空间使用情况
  * 可以通过-Xmx和-Xms来控制堆大小
  * 扩展：对象不一定是在堆上分配，还可能在TLAB上分配或基于逃逸分析直接在栈上分配

* 方法区

  * 线程共享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等
  * 方法区也叫 **Non-Heap**(非堆)，与Java堆区分开
  * 在HotSpot虚拟机中，方法区也可以称为**永久代(Permanent Generation)**，因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说是使用永久代实现方法区，这样GC可以像管理Java堆一样管理这部分内存
  * 方法区的垃圾收集行为比较少，内存回收的目标主要是针对常量池的回收和对类型的卸载

* 运行时常量池

  * 方法区的一部分
  * Class文件中除了有类的版本、字段、方法、接口等描述信息，还有常量池(Constant Pool Table)，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放
  * 程序运行期间也可能将的新的常量放入池中，比如String的intern()方法


###### 对象

* 对象的创建（仅限于普通对象，不包括数组和Class对象）
  * new一个对象时，首先检查是否能在常量池中定位到该类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有，先执行类加载过程
  * 类加载检查通过之后，虚拟机为新生对象分配内存，类加载完成后所需内存大小是完全确定的，从Java堆中分配一块确定大小的内存即可
  * 分配算法：
    * 指针碰撞（堆内存绝对规整）
    * 空闲列表（堆内存不规整，已使用的内存和空闲的内存相互交错）
* 对象的内存布局
  * 对象头，包含两部分
    * 第一部分存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向锁ID、偏向时间戳，称为“Mark Word"
    * 第二部分是类型指针，即对象指向它的类元数据的指针，jvm通过这个指针来确定这个对象是哪个类的实例
  * 实例数据
    * 对象真正存储的有效信息，即代码中所定义的各字段内容，包括父类继承下来的
    * 存储顺序受虚拟机分配策略参数和字段在Java中源码中定义顺序的影响
  * 对齐填充
    * 对象起始地址必须是8字节的整数倍
* 对象的访问定位
  * 对象访问方式取决于虚拟机的具体实现，主流的访问方式有两种：
  * 句柄：Java堆中要划分一块内存来作为句柄池，引用变量存储的是对象的句柄地址
    * 优点：reference中存储的是稳定的句柄地址，对象被移动只改变句柄中的实例数据指针
  * 直接指针：引用变量存储的就是对象地址
    * 优点：速度更快，节省一次指针定位的开销

##### 二、垃圾收集器和内存分配策略

GC需要完成的三件事情：

###### 哪些内存需要回收

* Java堆和方法区的内存需要回收，因为程序只有处于运行期间才能摘掉会创建哪些对象，这部分内存的分配和回收都是动态的

###### 什么时候回收

* 一个不可能再被任何途径使用的对象应该回收。
* 如何判断一个对象“已死”：
  * 引用计数法：给对象添加一个引用计数器，有地方引用就加1，引用失效就减1，为0时对象就不可能再被使用
    * 实现简单，判定效率高
    * 难以解决对象之间相互循环引用的问题
  * 可达性分析算法（根搜索算法）：通过一系列"GC Roots"对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为**引用链**，如果一个对象到GC Roots对象没有任何引用链相连（就是说GC Roots到这个对象不可达），说明此对象是不可用的。
    * GC Roots对象（因为GC管理的主要区域是Java堆，方法区、栈和本地方法区不被GC管理，因此选择这些区域内的对象作为GC Roots）
      * 虚拟机栈（栈帧中的本地变量表）中引用的对象、当前运行线程的栈上引用的对象
      * 方法区中的类静态变量引用的对象
      * 方法区中常量引用的对象
      * 本地方法栈中JNI（Native方法）引用的对象
  * 四种引用：描述这样一种对象：内存空间足够时保留在内存中，内存空间在进行垃圾回收之后还是非常紧张，就抛弃这些对象。
    * 强引用：代码中普遍存在，只要强引用存在，GC永远不会回收掉被引用的对象。
    * 软引用(SoftReference)：描述一些还有用但并非必需的对象，在发生内存溢出之前，把软引用关联的对象列进回收范围之内进行第二次回收，常用来设计**object-cache**
    * 弱引用(WeakReference)：弱引用关联的对象只能生存到下一次GC发生之前，即GC时，无论内存是否足够都会被回收掉，
      * 应用场景：希望能随时取得某对象的信息，但又不想影响此对象的垃圾收集，在设计Optimizer或Debugger的程序时常用到
    * 虚引用(PhantomReference)：设置虚引用的唯一目的就是能在这个对象被GC时收到一个系统通知
* 被GC判定为垃圾的对象一定会被回收吗
  * 可达性分析算法中不可达的对象不一定会被回收，一个对象“死亡”，有两次标记过程
    * 第一次标记：
      * 对象在进行可达性分析后发现没有与GC Roots相连接的引用链，第一次标记并根据此对象是否有必要执行finalize()方法进行筛选。
      * 对象没有覆盖finalize()方法，或者finalize()已经被虚拟机调用过，这两种情况视为“没有必要执行“
      * 如果对象有必要执行finalize方法，该对象会被放置在**F-Queue**队列中，稍后由一个虚拟机自动建立、低优先级的**Finalizer线程**去执行，所谓执行只是会触发这个方法，不会等待它执行结束
      * finalize()方法时对象逃脱死亡命运的最后一次机会
    * 第二次标记：
      * GC对F-Queue队列中对象进行第二次小规模的标记
      * 对象要拯救自己，只要重新与引用链上的任何一个对象建立关联即可

###### 如何回收（垃圾收集算法）

* 标记-清除算法(Mark-Sweep)
  * 基本思想：首先标记所有需要回收的对象，标记完成后统一回收
  * 优点：不需要进行对象的移动，仅对不存活得对象进行清除，在空间中存活对象较多的情况下较为高效
  * 缺点：
    * 效率：标记和清除的效率都不高
    * 空间：标记清除后产生大量不连续的内存碎片，导致分配大对象时无法找到足够的连续的内存
* 复制算法
  * 基本思想：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。这块空间用完了，就将存活对象复制到另一块空间，然后该空间一次清理掉。
  * 优点：每次都是对整个半区进行内存回收，内存分配也就不用考虑内存碎片的情况，只要移动堆顶指针顺序分配即可，实现简单，运行高效
  * 缺点：将内存缩减一般，代价太高；如果对象存活率较高就要进行较多的复制操作，效率也会变低
  * 新生代适合采用这种复制算法，新生代的回收为**Minor GC**
    * **堆内存中的新生代**按照8：1：1的比例划分为Eden：Survivor：Survivor空间
    * 每次只使用Eden和一块Survivor，回收时将这两块中还存活着的对象一次性复制到另一块Survivor，然后进行清理
    * 存活着的对象要复制到另一块Survivor中，当这块内存不够时，需要依赖其他内存（老年代）进行分配担保
* 标记-整理算法
  * 基本思想：首先标记所有需要回收的对象，标记完成后让所有存活对象都向一端移动，然后清理掉端边界以外的内存
  * 优点：不产生内存碎片
  * 适用于老年代，老年代的回收为**Major GC**。
* 分代收集算法
  * 堆内存空间根据对象存活周期的不同划分为新生代和老年代，新生代因为每次垃圾收集都有大批对象回收采用**复制算法**，老年代因为对象存活率高就采用**标记-清除或者标记-整理算法**进行回收。

###### 内存分配和回收策略

* 对象优先在Eden分配
  * 大多数情况下，对象在新生代的Eden区分配，Eden区空间不够，虚拟机将发起一次Minor GC
* 大对象直接进入老年代
  * 大对象：需要大量连续内存空间的Java对象，比如，很长的字符串以及数组
  * 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的空间安置它们
  * -XX:PretenureSizeThreshold，大于这个设置值的对象在老年代分配，以避免在Eden区和两个Survivor区之间发生大量的内存复制
* 长期存活的对象将进入老年代
  * 虚拟机给每个对象定义了一个对象年龄计数器
  * 一个对象在出初始在Eden分配，经过一次Minor GC后仍然存在，并且能放进Survivor，就会被移动到Survivor空间，此时对象的年龄设为1
  * 对象在Survivor区每经过一Minor GC仍然存活，年龄加1
  * 年龄加到一定程度（默认15，年龄阈值：-XX:MaxTenuringThreshold）就会移到老年代
* 动态年龄判定
  * 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象直接进入老年代

##### 三、Java内存模型(JMM)

###### 关于JMM

* JMM，屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
* JMM的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节
* 这里说的变量是指实例字段、静态字段、数组对象构成的元素，不包括局部变量和方法参数

###### 主内存和工作内存

* JMM规定所有的变量都存储在主内存中（虚拟机内存的一部分）
* 每个线程有自己的工作内存（类似于高速缓存），存储该线程使用到的变量的主内存副本拷贝，线程对该变量的所有操作都必须在工作内存中进行，而不能在主存中直接读写。
* 不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存来完成

###### 内存间交互操作

* 一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存
* 交互操作有8种操作，每一种操作都是原子的、不可再分的：
  * lock(锁定)：作用于主内存的变量，把一个变量标识为一条线程独占的状态
  * unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来
  * read(读取)：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存，以便随后的load动作使用
  * load(载入)：作用于工作内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中
  * use(使用)：作用于工作内存的变量，把工作内存中一个变量的值传递给执行引擎
  * assign(赋值)：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量
  * store(存储)：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中
  * write(写入)：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量
* volatile变量的特殊规则
  * 最轻量级的同步机制
  * volatile变量有两种特性：
    * 可见性：保证此变量对所有线程的可见性，即当一个线程修改了这个变量的值，新值对于其他线程可以立即得知，换句话说，volatile变量在各个线程中是一致的
    * 禁止指令重排序优化：
      * 普通变量保证在一个方法执行过程中，所有依赖赋值结果的地方虽然都能获得正确的结果，但不能保证变量赋值的顺序和程序代码中的执行顺序一致
      * volatile变量编译成字节码后会多一条指令操作，这个操作相当于一个内存屏障，这样指令排序时不能把后面的指令重排序到内存屏障之前的位置
  * volatile不保证原子性：一个i++操作编译成字节码会有好几条指令，这几条指令的执行并非原子的，因此volatile变量仍存在不一种的情况

###### 原子性、可见性和有序性

Java内存模型就是围绕在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的

* 原子性：基本数据类型的访问读写是具备原子性的，如果需要一个更大范围的原子性保证，JMM提供lock和unlock操作来保证，这是由更高层次的字节码指令monitorenter和moniterexit隐式使用，这两个字节码指令反映到Java代码中就是同步块--synchronized关键字。
* 可见性：一个线程修改了一个共享变量，其他线程能立即得知这个修改。除了volatile还有两个关键字可以实现可见性
  * synchronized：对一个变量执行unlock操作之前，必须先把此变量同步回主内存中
  * final：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把"this"的引用传递出去，那么其他线程就能看见final字段的值。
* 有序性：如果在本线程内观察，所有的操作都是有序的（**线程内表现为串行化的语义**）；如果在一个线程中观察另一个线程，所有的操作都是无序的（**指令重排序和工作内存与主内存同步延迟**）。
  * volatile和synchronized都可以保证线程之间操作的有序性

##### 四、线程安全与锁优化

###### 线程安全

* 定义：多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要额外的同步，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

* 按照线程安全的“安全程度”由强至弱排序，Java中各种操作共享的数据可分为5类：

  * 不可变：不可变的对象一定是线程安全的，final修饰的基本数据类型就是不可变的
  * 绝对线程安全：不管运行时环境如何，调用者都不需要任何额外的同步措施。这个要求时非常严格的，很难达到。
  * 相对线程安全：只需要保证对这个对象单独的操作是线程安全的，Java中大部分线程安全的类都属此例，如Vector, HashTable, Collections的synchronizedCollection()方法包装的集合
  * 线程兼容：对象本身不是线程安全的，但可以通过在调用端正确地使用同步手段来保证对象在并发环境下可以安全的使用
  * 线程对立：无论调用端是否采取同步措施，都无法保证线程安全

* 线程安全的实现方法

  * 互斥同步（阻塞同步）：最主要的问题就是进行线程阻塞和唤醒所带来的性能问题
    * 同步是指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用，互斥是实现同步的手段
    * 临界区、互斥量、信号量都是主要的互斥实现方式
    * 最基本的互斥同步手段：synchronized
      * synchronized关键字经过编译后，会在同步块的前后分别形成monitorenter和monitorexit两个字节码指令，这两个指令都需要一个引用类型的参数来指明要锁定的解锁的对象
      * 如果synchronized明确指明了对象参数，那就是这个对象的引用；如果没有，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象作为锁对象
      * 执行monitorenter指令时，首先要尝试获取对象的锁，如果这个对象没锁定或者当前线程已经拥有了那个对象的锁，锁的计数器加1，执行monitorexit时锁的计数器减1，计数器为0时释放锁。
      * 如果获取对象锁失败，当前线程就要阻塞等待，等到对象锁被另一个线程释放为止
      * 注意两点：
        * synchronized同步块对同一个线程来说是可重入的，不会自己把自己锁死
        * 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入
    * 使用java.util.concurrent包中的重入锁(ReentrantLock)来实现同步
      * 相比synchronized，ReentrantLock多了一些高级功能
        * 等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待
        * 可实现公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，synchronized中的锁时非公平的，ReentrantLock默认也是非公平的，但可以通过带布尔值的构造函数使用公平锁
        * 锁可以绑定多个条件：一个ReentrantLock对象可以同时绑定多个Condition对象
  * 非阻塞同步
    * 一种基于冲突检测的乐观的并发策略，先进行操作，如果没有其他线程争用共享数据，那操作成功，如果有争用，产生了冲突，再采取其他的补偿措施。这种策略不需要把线程挂起，所以叫非阻塞同步
    * 这种策略需要硬件指令集提供支持，即有硬件保证操作和冲突检测的原子性
    * 这种指令有：
      * 测试并设置(Test-and-Set)
      * 获取并增加(Fetch-and-Increment)
      * 交换(Swap)
      * 比较并交换(Compare-and-Swap, CAS)
        * CAS指令需要3个操作数，分别是内存位置V，旧的预期值A，新值B
        * CAS指令执行时，当且仅当V符合A时，处理器才用B更新A，否则不更新，最后返回V的旧值，这个过程是一个原子操作
      * 加载链接/条件存储(Load-Linked/Store-Conditional, LL/SC)
  * 无同步方案
    * 可重入代码
    * 线程本地存储：把共享数据的范围限制在同一个线程之内
      * 应用场景：大部分消费队列的i架构模式都会将产品的消费过程尽量在一个线程中消费完，比如，经典Web交互模型中的“一个请求对应一个服务器线程”的处理方式
      * java.lang.ThreadLocal类可实现线程本地存储的功能

###### 锁优化

  - 自旋锁
    - 引出场景：互斥同步需要阻塞，会有挂起和恢复线程的操作，而这些操作需要转入到内核态中去完成，在实际应用中，共享数据的锁定状态只会持续很短的时间，为了这段时间去挂起和恢复一个线程并不值得。因此可以让后面请求锁的线程“稍等一下”，但不放弃处理器时间，看看持有锁的线程是否会很快释放锁。
    - 所谓自旋锁，就是指为了让线程等待，让线程执行一个忙循环，这个忙循环就是自旋
    - 自旋等待的时间需要有一个限度，如果自旋超过了限定的次数还没有获得锁，就要挂起
    - 自旋次数默认是10，使用-XX:PreBlockSpin更改
  - 锁消除
    - 虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除
    - 比如，如果判断出在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当作栈上的数据对待，认为是线程私有的，就不用同步加锁
  - 锁粗化
    - 大部分情况下，同步块的作用范围总是限制得尽量小，只在共享数据的实际作用域才进行同步
    - 某些情况下，存在一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中，这样频繁的互斥同步操作会导致不必要的性能损耗
    - 这种情况下，虚拟机就会把加锁同步的范围扩展（粗化）到整个操作序列的外部
- 轻量级锁

  - 在无竞争的情况下使用CAS操作消除同步使用的互斥量
- 偏向锁
  - 在无竞争的情况下把整个同步都消除掉，连CAS操作都不做
  - 所谓“偏”，是指这个锁会偏向于第一个获得它的线程，如果之后的执行中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步


